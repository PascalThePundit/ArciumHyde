use anchor_lang::prelude::*;

// Define the program ID - in a real project, this would be generated by Anchor
declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod arcium_encrypted_compute {
    use super::*;

    // Initialize a new encrypted compute account
    pub fn initialize_encrypted_compute(ctx: Context<InitializeEncryptedCompute>, data_hash: String) -> Result<()> {
        // Validate data hash is not empty
        require!(!data_hash.is_empty(), ErrorCode::InvalidData);
        // Limit the length of the hash to prevent excessive storage costs
        require!(data_hash.len() <= 256, ErrorCode::DataTooLong);

        let encrypted_compute = &mut ctx.accounts.encrypted_compute;
        encrypted_compute.authority = ctx.accounts.user.key();
        encrypted_compute.data_hash = data_hash;
        encrypted_compute.encrypted_data = String::new();
        encrypted_compute.status = "initialized".to_string();
        encrypted_compute.created_at = Clock::get()?.unix_timestamp;
        encrypted_compute.updated_at = Clock::get()?.unix_timestamp;
        encrypted_compute.time_lock_expiration = 0;  // No time lock by default
        encrypted_compute.is_locked = false;
        encrypted_compute.unlock_conditions_met = false;
        
        Ok(())
    }

    // Update encrypted data
    pub fn update_encrypted_data(ctx: Context<UpdateEncryptedData>, encrypted_data: String) -> Result<()> {
        // Validate encrypted data is not empty
        require!(!encrypted_data.is_empty(), ErrorCode::InvalidData);
        // Limit the length to prevent excessive storage costs
        require!(encrypted_data.len() <= 1024, ErrorCode::DataTooLong);

        let encrypted_compute = &mut ctx.accounts.encrypted_compute;
        
        // Only the authority can update the data
        require!(
            *ctx.accounts.user.key == encrypted_compute.authority,
            ErrorCode::Unauthorized
        );

        encrypted_compute.encrypted_data = encrypted_data;
        encrypted_compute.status = "updated".to_string();
        encrypted_compute.updated_at = Clock::get()?.unix_timestamp;
        
        Ok(())
    }

    // Process encrypted computation (placeholder for Arcium integration)
    pub fn process_encrypted_computation(ctx: Context<ProcessEncryptedComputation>) -> Result<()> {
        let encrypted_compute = &mut ctx.accounts.encrypted_compute;
        
        // Only the authority can process computation
        require!(
            *ctx.accounts.user.key == encrypted_compute.authority,
            ErrorCode::Unauthorized
        );

        // Ensure the account has been initialized with data
        require!(
            !encrypted_compute.encrypted_data.is_empty(),
            ErrorCode::NoEncryptedData
        );

        // Placeholder for actual encrypted computation
        encrypted_compute.status = "processed".to_string();
        encrypted_compute.updated_at = Clock::get()?.unix_timestamp;
        
        Ok(())
    }

    // Close the encrypted compute account and reclaim rent
    pub fn close_encrypted_compute(ctx: Context<CloseEncryptedCompute>) -> Result<()> {
        let encrypted_compute = &mut ctx.accounts.encrypted_compute;

        // Only the authority can close the account
        require!(
            *ctx.accounts.user.key == encrypted_compute.authority,
            ErrorCode::Unauthorized
        );

        // Update status to closed
        encrypted_compute.status = "closed".to_string();
        
        Ok(())
    }
}

#[derive(Accounts)]
#[instruction(data_hash: String)]
pub struct InitializeEncryptedCompute<'info> {
    #[account(
        init,
        payer = user,
        space = 8 + 32 + 4 + 256 + 4 + 1024 + 4 + 32 + 8 + 8 + 8 + 1 + 1, // discriminator + authority + data_hash_len + data_hash + encrypted_data_len + encrypted_data + status_len + status + created_at + updated_at + time_lock_expiration + is_locked + unlock_conditions_met
        seeds = [b"encrypted_compute", user.key().as_ref(), data_hash.as_bytes()],
        bump
    )]
    pub encrypted_compute: Account<'info, EncryptedCompute>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct UpdateEncryptedData<'info> {
    #[account(
        mut,
        seeds = [b"encrypted_compute", encrypted_compute.authority.as_ref(), encrypted_compute.data_hash.as_bytes()],
        bump,
    )]
    pub encrypted_compute: Account<'info, EncryptedCompute>,
    #[account(mut)]
    pub user: Signer<'info>,
}

#[derive(Accounts)]
pub struct ProcessEncryptedComputation<'info> {
    #[account(
        mut,
        seeds = [b"encrypted_compute", encrypted_compute.authority.as_ref(), encrypted_compute.data_hash.as_bytes()],
        bump,
    )]
    pub encrypted_compute: Account<'info, EncryptedCompute>,
    #[account(mut)]
    pub user: Signer<'info>,
}

#[derive(Accounts)]
pub struct CloseEncryptedCompute<'info> {
    #[account(
        mut,
        seeds = [b"encrypted_compute", encrypted_compute.authority.as_ref(), encrypted_compute.data_hash.as_bytes()],
        bump,
        close = user
    )]
    pub encrypted_compute: Account<'info, EncryptedCompute>,
    #[account(mut)]
    pub user: Signer<'info>,
}

#[account]
pub struct EncryptedCompute {
    pub authority: Pubkey,           // The owner of this account
    pub data_hash: String,          // Hash of the original data
    pub encrypted_data: String,     // Encrypted data stored on-chain
    pub status: String,             // Current status of computation
    pub created_at: i64,            // Timestamp when account was created
    pub updated_at: i64,            // Timestamp when account was last updated
    pub time_lock_expiration: i64,  // Timestamp when data becomes available (0 if no time lock)
    pub is_locked: bool,            // Whether the data is currently locked
    pub unlock_conditions_met: bool,// Whether unlock conditions have been met
}

#[error_code]
pub enum ErrorCode {
    #[msg("Unauthorized access to account")]
    Unauthorized,
    #[msg("Invalid data provided")]
    InvalidData,
    #[msg("Data provided is too long")]
    DataTooLong,
    #[msg("No encrypted data found in account")]
    NoEncryptedData,
}